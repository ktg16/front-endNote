### 类变量 static

```
class Child { //类
  private String name;
  //定义一个变量 count ,是一个类变量(静态变量) static 静态 //该变量最大的特点就是会被 Child 类的所有的对象实例共享 public static int count = 0;
  public Child(String name) {
  this.name = name; }
  public void join() {
  System.out.println(name + " 加入了游戏..");
  } }
```

1.static变量是同一个类所有对象共享

2.static类变量 在类加载的时候就生成了

定义语法： 

访问修饰符 static  数据类型  变量名;

Static  访问修饰符 数据类型  变量名

使用 类名.类变量名方式来访问 是可以的

![image-20230525155840277](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230525155840277.png)

### 类方法 static

#### 注意事项

![image-20230525154946063](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230525154946063.png)

小结:记住两句话 (1) 静态方法，只能访问静态成员 (2) 非静态方法，可以访问所有的成员 (3) 在编写代码时，仍然要遵守访问权限规则

### 理解 main 方法语法

![image-20230525171843295](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230525171843295.png)

调用main方法 需要public方法 执行时需要statice()静态方法

特别提示:

1.在main方法 可以直接调用main方法所在的静态方法或静态属性

2.main方法不能直接访问该类的非静态成员。必须创建该类的一个实例对象后，才能访问

### 代码块



细节注意事项

1.static 代码块也叫静态代码块 作用是对类进行初始化 而且它是随着类的加载而执行，并且**只会执行一次**。

普通代码块每创建一个对象。才执行（创建一个对象调用一次）

```java
class A{
    private  int n2 = 10;
    static {
        System.out.println("A");
    }
}

class B extends A {
    private  int n2 = 20;
    public  static  int totalNum = 100;
    static {
        System.out.println("B");
    }
}
```

2.类什么时候被加载（重要）

1.创建对象实例

2.创建子类对象实例

3.使用类的静态成员时

3.普通的代码块，在创建对象实例时。会被隐式调用。

被创建一次，就会被调用一次。如果只是使用类的静态成员时，普通代码块并不会执行

#### 4.创建一个对象时，在一个类调用顺序是(重点，难点)：

1.优先调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一致，按照顺序来执行即可）

2.调用普通代码块和普通属性初始化

3.调用构造方法



#### 5.构造器的最前面其实隐含了super()和调用普通代码块

```
class AAA { //父类 Object {
System.out.println("AAA 的普通代码块"); }
public AAA() { //(1)super()
//(2)调用本类的普通代码块
System.out.println("AAA() 构造器被调用...."); }
```

#### 6.子类对象 调用顺序

1.父类的静态代码块 和 静态属性

2.子类的静态代码块和静态属性

3.父类的普通代码块和普通属性

4.父类的构造函数

5.子类普通代码块和普通属性

6.子类的构造函数

7.静态代码块只能调用 静态成员 ， 普通代码块可以调用任意成员

### 单例设计模式

饿汉式：类加载了，就创建一个 静态属性（未使用就已经加载好了，为了能都在静态方法中获取）

定义个静态对象属性

```
class GirlFriend{
	private String name;
	
	public static int n1 = 100;
	private static GirlFriend gf = new GirlFriend()
	private GirlFriend(String name) {
    System.out.println("構造器被調用.");
    this.name = name; 
    }
	public static GirlFriend getInstance() { return gf;
}
}

```

懒汉式：

定义一个静态属性（不消耗资源 但是存在线程问题）

```
public class SingleTon02{
	public static void main(){
		Cat instance = Cat.getInstance(); 		
    
    System.out.println(instance);

	}
}

class Cat {
private String name;
public static int n1 = 999;
private static Cat cat ; //默認是 null 
//步驟
//1.仍然構造器私有化
//2.定義一個 static 靜態屬性對象
//3.提供一個 public 的 static 方法，可以返回一個 Cat 對象
//4.懶漢式，只有當用戶使用 getInstance 時，才返回 cat 對象, 後面再次調用時，會返回上次創建的 cat 對象 // 從而保證了單例
private Cat(String name) {
		System.out.println("構造器調用...");
		this.name = name; }
		
public static Cat getInstance() {
			if(cat == null) {//如果還沒有創建 cat 對象 
			cat = new Cat("小可愛");
		}
	return cat;
}
```

### final关键字：

![image-20230527100223056](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230527100223056.png)

修饰不可修改的属性和方法

使用fianl时需要注意的地方⚠️

🍉 final修饰❕的属性又叫常量。一般使用XX_XX_XX来命名

🍎在定义时必须赋初值 且不能更改，在如下位置赋值：

​		1.定义时2.构造器中 3.在代码块中

![image-20230527100819645](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230527100819645.png)

6.fianl类 就不需要fianl方法（目的是为了防止重写）

7.fianl不能修饰构造器

8.final和static往往搭配使用，效率更高 不会导致类的加载，底层编译器做了优化

9.包装类（Integer double float Boolean等都是final） String也是final类

### 如何改变浏览器控制台输出文字的样式

https://baijiahao.baidu.com/s?id=1759040297585393415&wfr=spider&for=pc

app uploader解决ios上架问题

https://zhuanlan.zhihu.com/p/44203227

https://nottwoc.com/guide/ios2.html#p8%E8%AF%81%E4%B9%A6-apns-auth-key-%E4%B8%89%E4%B8%AA%E7%AB%AF%E5%8F%AA%E9%9C%80%E4%B8%80%E4%B8%AA%E5%8D%B3%E5%8F%AF-%E4%B8%8A%E4%BC%A0%E5%88%B0-dcloud-unipush

https://blog.csdn.net/m0_74760716/article/details/128116187?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168480925416800188532233%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=168480925416800188532233&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-128116187-null-null.142^v87^control_2,239^v2^insert_chatgpt&utm_term=hb%E5%A6%82%E4%BD%95%E6%89%93%E5%8C%85%E5%88%B0iphone%E6%89%8B%E6%9C%BA&spm=1018.2226.3001.4187



打包

### 抽象类 abstract

当父类的一些方法不能确实时，使用abstract关键字来修饰该方法，这个方法就是抽象方法 还需要用abstract类来修饰该类就是抽象类

```
abstract class Animal  {
	Sting name;
	int age;
	abstract public void cry();//	不能由方法体
}
//子类来继承抽象类 重写类 
```

在与设计模式相关的使用比较多

注意事项：

1.不能被实例化

2.抽象类不一定要包含abstract方法，抽象类可以没有abstract方法

3.类包含了abstract方法，则这个类必须声明为abstract

4.abstract只能修饰类和方法 不能修饰属性和其他的

5.抽象咧可以有任意成员【抽象类本质还是类】 比如：非抽象方法 构造器 静态属性

6.抽象方法不能有主体，既不能实现



7.一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类

8.不允许和private、final、static来修饰



### 抽象类最佳实践-模板设计模式

![image-20230529105127621](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230529105127621.png)

1.有多个类，完成不同的任务job

2.要求统计得到各自完成任务的时间

```
abstract public class template {
    abstract public void job();

    public void calculateTime(){
        long start = System.currentTimeMillis();
        job();
        long end =  System.currentTimeMillis();
        System.out.println("任务时间"+(end - start));
    }

}

public class AA extends template{
    @Override
    public void job() {
        long num = 0;
        for (int i = 0; i < 800000; i++) {
            num+=i;
        }
    }
}

public class TestTemplate{
	public static void main(String[] args){
			AA aa = new AA();
			aa.calculateTime();
	}
}
```

