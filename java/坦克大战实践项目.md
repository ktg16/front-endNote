# 看完再记录！！！

### java 绘图坐标体系

![image-20230626140743518](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230626140743518.png)



#### 像素

计算机显示的内容都是用屏幕的每一个像素组成的； 

比如一个一样大的屏幕   像素是不同的代表着密度不同

像素是密度单位。厘米是长度单位

### 事件处理机制

**事件源**产生一个**事件/对象** 交给 **事件监听者  事件处理方法**

### 线程基础

程序：完成特定任务。用某种语言编写的一组指令的集合

简单说：就是我们写的代码

进程

1.进程是指运行中的程序。 比如我们使用qq就启动一个进程，操作系统就会为该进程 分配内存空间   当我们使用迅雷 又启动一个进程 操作系统将为迅雷分配新的内存空间

2.进程是程序的一次执行过程。或是正在运行的一个程序。是动态过程，有它自认的产生 存在和消亡的过程

线程

线程是由进程创建的。是进程的一个实体

单线程、多线程

并发：同一时刻 多个任务交替执行，造成一种“貌似同时”的错觉，简单的来说    单核cpu实现的多任务就是并发

并行：同一时刻。多个任务同时执行。多核cpu可实现并行

#### 线程使用

```
Cat cat = new Cat();
cat.start();

class Cat extends Thread {
int times = 0;
@Override
public void run() {//重写 run 方法，写上自己的业务逻辑
while (true) {
//该线程每隔 1 秒。在控制台输出 “喵喵, 我是小猫咪”
System.out.println("喵喵, 我是小猫咪" + (++times) + " 线程名=" + Thread.currentThread().getName());
```

同时使用多个线程

```
public class Thread03 {
  public static void main(String[] args) {
  T1 t1 = new T1();
  T2 t2 = new T2();
  Thread thread1 = new Thread(t1); 
  Thread thread2 = new 	Thread(t2); 
  thread1.start();//启动第 1 个线程 thread2.start();//启动第 2 个线程 //...
  // 继承Thread 实现不了 一个资源多个线程
  
  Thread thread3 = new Thread(t3) 
  thread.start();
  }
 }
```

![image-20230705143611785](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230705143611785.png)

#### 线程终止

#### 线程常用方法

```
setName(name) 设置线程名称
getName()
start
run 
setPriority
getPriority
sleep 休眠
interrupt 中断线程
```

join。线程插队 

yield 线程礼让。 cpu紧张时礼让

#### 用户线程与守护线程

比如 垃圾回收机制

T t = new T()

t.setDaemon(true) //设置为守护线程

#### 线程生命周期（线程7大状态）

NEW

尚未启动线程

RUNNABLE

在 java虚拟机中执行线程

BLOCKED

被阻塞等待监视器锁定的线程

WAITING

等待另一个线程

TIMED_WAITING

正在等待另一个线程执行动作到达等待时间的线程处于此状态

TERMINATED

已经退出的线程处于此状态

![image-20230706102302223](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230706102302223.png)

t.getState()//观察线程状态

#### 线程的同步

线程同步: 即当有一个线程在对内存进行操作时。其他线程都不可以对这个内存地址进行操作。直到该线程完成操作。 其他线程才能对该内存地址进行操作

```
1.同步代码块
synchronized(对象){
	//得到对象的锁，才能操作同步代码
}
2.synchronized还可以在方法声明。 表示整个方法

public synchronized void m (String name){
	需要被同步的代码块
}

```

#### 互斥锁

![image-20230706135753261](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230706135753261.png)

```
//1. public synchronized void sell() {} 就是一个同步方法
//2. 这时锁在 this 对象
//3. 也可以在代码块上写 synchronize ,同步代码块, 互斥锁还是在 this 对象


public /*synchronized*/ void sell() { /
synchronized (/*this*/ object) { if (ticketNum <= 0) {
System.out.println("售票结束..."); loop = false;
return;
}
//休眠 50 毫秒, 模拟 try {
Thread.sleep(50);
} catch (InterruptedException e) {
e.printStackTrace(); }
System.out.println("窗口 " + Thread.currentThread().getName() + " 售出一张票"
+ " 剩余票数=" + (--ticketNum));//1 - 0 - -1
- -2
} }
```

同步方法如果没有使用 static修饰 默认锁对象为 this

如果方法使用 static修饰。默认锁对象：当前类

```
同步方法 静态的锁 为当前类本身
public synchronized static void m1() {
}
public static void m2() {
synchronized (SellTicket03.class) { System.out.println("m2");
} }
```

实现落地步骤：

1.需要先分析上锁的代码（会发生堵塞）

2.选择同步代码块和同步方法

3.要求多个线程的锁 对象为同一个即可

所以静态static需要锁对象而不是this（会出现三把锁）

#### 死锁

多个线程都占用了对方的锁资源。但不肯想让 导致了死锁，编程时一定要避免死锁的发生

```
public void run() {
//下面业务逻辑的分析
//1. 如果 flag 为 T, 线程 A 就会先得到/持有 o1 对象锁, 然后尝试去获取 o2 对象锁 //2. 如果线程 A 得不到 o2 对象锁，就会 Blocked
//3. 如果 flag 为 F, 线程 B 就会先得到/持有 o2 对象锁, 然后尝试去获取 o1 对象锁 //4. 如果线程 B 得不到 o1 对象锁，就会 Blocked
    if (flag) {
    synchronized (o1) {//对象互斥锁, 下面就是同步代码 
    System.out.println(Thread.currentThread().getName() + " 进入 1"); 
     synchronized (o2) { // 这里获得 li 对象的监视权
    System.out.println(Thread.currentThread().getName() + " 进入 2"); }
    } } else {
    synchronized (o2) {   
    System.out.println(Thread.currentThread().getName() + " 进入 3"); 
    synchronized (o1) { // 这里获得 li 对象的监视权
    System.out.println(Thread.currentThread().getName() + " 进入 4"); }
  }
}
```

### 坦克大战 0.3设计思路



1.当发射一颗子弹,就相当于启动一个线程

2.hero有子弹的对象。当按下j 我们就启动一个发射行为(线程)  让子弹不停的移动 形成一个射击的效果

3.我们MyPanel 需要不停的重绘子弹。才能出现 该效果

4.移动至边界时 应该销毁







0.4

绘制新的子弹

1.我方子弹消亡后 发射新的子弹

按下j键判断 是否销毁

如果没有销毁 就不去触发 shotEnemy

销毁才去触发

发射多个子弹如何解决

创建 Vector() 实现子弹对象

2 敌人子弹消亡后。再发射子弹 

直接判断敌人子弹的isLive



isLive消失再次发射

3.当敌人坦克击中我方坦克  我方坦克消失

遍历子弹是不是击中坦克的位置

