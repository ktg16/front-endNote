java项目实战

### 1.前端环境搭建

### 2.后端环境构建

使用maven进行项目构建。分模块开发





#### dto vo的含义

common  模块 存放公共类

 pojo模块 存放实体类(domain)

entity 实体 通常和数据库中的表对应

DTO 数据传输对象。用于程序中各层之间传递 Data Transfer Object

VO 视图对象 为前端展示数据提供的对象

POJO 普通java对象 只有属性和对应的getter和setter

server模块 后端服务 存放配置文件

配置类、拦截器、controller、service、mapper（持久层 sql）、启动类

**1.一般不需要自己建包，直接把代码拉下来就可以了**

**2**.数据库环境搭建

通过数据库建表语句创建数据库表结构

3.前后端联调测试

1编译一下compile

2.

登录之后的操作

mybatis

登录成功，生成jwt令牌



### nginx配置

反向代理

```
upstream webservers{
					server 192.168.100.128:8080 weight = 90;
					server 192.168.100.128:8080 weight = 10;
}

server{
			listen 80;
			server_name localhost;
			
			location /api/ {
					proxy_pass http://webservers/admin //负载均衡
			}
}
```

![image-20230807150445740](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230807150445740.png)

swagger的配置 

全称为Value Object,其实就是一个普通的JavaBean。一般配合DAO来使用，用于实例化对象。

一般将数据库的操作封装在DAO内，把从数据库查询到的信息实例化为VO，然后再进行各种操作。

### 新增员工接口

1.需求分析和设计

2.代码开发

```
    @Override
    public void save(EmployeeDTO employeeDTO) {
        Employee employee = new Employee();    //属性拷贝
        BeanUtils.copyProperties(employeeDTO, employee);
        //账号状态默认为1，正常状态
        employee.setStatus(StatusConstant.ENABLE);   //默认密码为123456
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));    //创建人、创建时间、修改人、修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        // TODO
        employee.setCreateUser(BaseContext.getCurrentId());//获取创建人id
        employee.setUpdateUser(BaseContext.getCurrentId());
        employeeMapper.insert(employee);
    }
```



```
    @PostMapping
    @ApiOperation("新增员工接口")
    public Result save(@RequestBody EmployeeDTO employeeDTO){ //json格式需要加注解
        employeeService.save(employeeDTO);
        log.info("新增员工：{}",employeeDTO);//{} 占位符号动态放到里面去
        return Result.success();
    }
```

3.功能测试

4.代码完善

解决异常 设置返回状态

```
    @ExceptionHandler
    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex){

        String message = ex.getMessage();
        if(message.contains("Duplicate entry")){
            String[] split = message.split(" ");
            String username = split[2];
            String msg = username + MessageConstant.ALREADY_EXISTS;
            return Result.error(msg);
        }else{
            return Result.error(MessageConstant.UNKNOWN_ERROR);
        }
    }
```

员工分页查询

#### 接口文档统一获取令牌

#### ThreadLocal

ThreadLocal 并不是一个Thread 而是Thread局部变量

为每一个线程提供存储空间 线程外不能访问

```
public class BaseContext {

    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }

    public static void removeCurrentId() {
        threadLocal.remove();
    }

}
```

### 分页查询员工接口

代码开发

1.设计DTO

```
public class EmployeePageQueryDTO implements Serializable {

    //员工姓名
    private String name;

    //页码
    private int page;

    //每页显示记录数
    private int pageSize;

}
```

返回的result

```
public class PageResult implements Serializable {

    private long total; //总记录数

    private List records; //当前页数据集合

}
```

2.调用service来实现分页查询

```
public PageResult page(EmployeePageQueryDTO employeePageQueryDTO) {
        PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize());
        Page<Employee> page=employeeMapper.pageQuery(employeePageQueryDTO);
        return new PageResult(page.getTotal(),page.getResult());
    }
```

使用 mybatis使用 pagehelper

3.写sql  使用动态标签需要映射文件

```
//需要yml中使用mapper配置文件
EmployeeMapper.xml
<select id="pageQuery" resultType="com.sky.entity.Employee">
        select <include refid="Base_Column_List"/>
        from employee
    <where>
        <if test="name != null and name !=''">
            name like concat('%',#{name},'%')
        </if>
    </where>
    order by create_time desc
    </select>
```

4.代码完善

对日期进行转换！！

```
// 1.在属性上加入注解，对日期进行格式化
    //@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createTime;
```







### 公共字段自动填充

```
@Target(ElementType.METHOD) //指定注解家在方法中
@Retention(RetentionPolicy.RUNTIME)
 public @interface AutoFill {
        //数据库操作类型：UPDATE INSERT
        OperationType value();//枚举方法。value是注解的属性
    }
```

使用AutoAspect统一添加公共属性

定义切面类

注解 @Aspect（切面类） @Compoent（定义bean类） @Slf4j（记录日志）

```
package com.sky.aspect;

import com.sky.annotation.AutoFill;
import com.sky.constant.AutoFillConstant;
import com.sky.context.BaseContext;
import com.sky.enumeration.OperationType;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.LocalDateTime;
import java.util.HashMap;

@Aspect
@Component
@Slf4j
//公共字段自动填充
public class AutoAspect {
    //@Pointcut("execution(* com.sky.mapper.*.insert*(..)) || execution( * com.sky.mapper.*.update*(..))")
    @Pointcut("@annotation(com.sky.annotation.AutoFill)")
    public void autoFillPointCut() {
    }

    @Before("autoFillPointCut()") // 前置通知  在通知中为公共字段赋值
    public void autoFill(JoinPoint joinPoint) {
        log.info("开始填充公共字段");
        String name = joinPoint.getSignature().getName();

        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);
        OperationType operationType = autoFill.value();
        Object[] args = joinPoint.getArgs();//获取参数 实体对象
        if (args == null || args.length == 0) return;
        Object entity = args[0];

        //初始数据准备
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();
        //根据当前不同的操作类型 为对应的属性通过反射来赋值
        if (operationType == OperationType.INSERT) {
            //if (name.contains("insert")) {
            try {
                //通过反射获取方法名，然后invoke方法注入方法对象和实参
                //使用getDeclaredMethod获取有参方法
                //可以根据方法命和参数tong
                Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
                Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);
//情况1字段填充
                //，第一个参数为实例对象，第二个参数为实参
                setCreateTime.invoke(entity, now);
                setUpdateTime.invoke(entity, now);
                setCreateUser.invoke(entity, currentId);
                setUpdateUser.invoke(entity, currentId);
            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                e.printStackTrace();
            }
        } else if (operationType == OperationType.UPDATE) {
            //else if (name.contains("update")){
            try {
                Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
                Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);
//情况2字段填充
                setUpdateTime.invoke(entity, now);
                setUpdateUser.invoke(entity, currentId);
            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                e.printStackTrace();
            }
        }
    }
}


```

上传文件

1.需要一个bucket存储空间

2.设置属性 

3.上传菜品(流程一致)

存在一个flavor需要添加一个新表 关联起来（）

```
    //需要加一个事物注解
//    @Transactional
```

```
1.创建 DishController
2.创建DishService 接口
3.DishServiceimpl 操作 @Service服务层标记
4.创建DishMapper  @Mapper编译时会产生相应的实现类(sql语句与sql交流)
5.DishFlavorMapper 菜品口味实现类 
6.创建DishMapper.xml 动态sql
```







aop定义

https://www.cnblogs.com/hongwz/p/5764917.html



### 面试题

1. Spring 的 IOC 和 AOP 是什么，有哪些优点？
2. Spring 框架用到了哪些设计模式？
3. 介绍 Spring Bean 的生命周期
4. MyBatis 如何实现延迟加载？
5. 介绍 MyBatis 的多级缓存机制

什么是spring mvc

使用 MVC 的目的是将 M 和 V 的实现代码分离，使同一个程序可以有不同的表现形式。其中，View 的定义比较清晰，就是用户界面。

Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。
Spring MVC 是结构最清晰的 Servlet+JSP+JavaBean 的实现。
由于 Spring MVC 本身就是 Spring 框架的一部分，可以说和 Spring 框架是无缝集成。性能方面具有先天的优越性，是当今业界最主流的 Web 开发框架，最热门的开发技能。
在 Spring MVC 框架中，Controller 替换 Servlet 来担负控制器的职责，用于接收请求，调用相应的 Model 进行处理，处理器完成业务处理后返回处理结果。Controller 调用相应的 View 并对处理结果进行视图渲染，最终客户端得到响应信息。
Spring MVC 的注解驱动和对 REST 风格的支持。

