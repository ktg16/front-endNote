## java中级部分

IDE基本使用

### ide快捷键

1.删除当前行 ctrl+d

2.复制当前行 ctrl+c

3.补全代码 alt+/

4.添加注释 ctrl + /

5.导入该行需要的类 先配置 auto import 使用alt+enter即可

6.快速格式化 ctrl+alt+L

7.快速运行 alt+r 

8.生成构造器 ctrl+n 						 					

9) 查看一个类的层级关系 ctrl + H [学习继承后，非常有用]  (破解之后才有) 						
10) 将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用]  ctrl+左键						
11) 自动的分配变量名 , 通过 在后面假 .var [老师最喜欢的] alt+回车  			

### 模版/自定义模版			

进阶的时候看 先手写 练一练手感

模版可以高效完成开发  提高速度 				

### 包

包的本质： 实际上就是创建不同的文件夹/目录来保存类文件

包的命名规则： 只能包含数字、字母、下划线、小圆点、但不能用数字开头，不能是关键字或保留字

demo.classs.exec1//x

命名规范：

一般是小写字母+小圆点

com.公司名.项目名.业务模块名

比如: com.enssi.his.use//用户模块

### 访问修饰符

![image-20230515092459031](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230515092459031.png)

不同包需要使用 import包引入，同一包下则不需要使用

### 面向对象编程--封装

封装就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序其他部分只有通过被授权的操作[方法]，才能对数据进行操作

![image-20230515094909171](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230515094909171.png)

将构造器和 setXxx 结合

```
public Person(String name, int age, double salary) {
// // //
      this.name = name; 
      this.age = age; 
      this.salary = salary;
      //我们可以将 set 方法写在构造器中，这样仍然可以验证 
      setName(name);
      setAge(age);
      setSalary(salary);
}

使用快捷键ctrl+i 构造get set
```

### 继承

继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中 抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来 声明继承父类即可

1.  代码的复用性提高了

2. 代码的扩展性和维护性提高了

   ```
   class子类 extends 父类{}
   子类就自动拥有父类定义的属性和方法
   子类又叫超类 基类
   子类又叫派生类
   ```

   继承细节问题

1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问

2. 子类必须调用父类的构造器，完成父类的初始化

3. 当创建子类对象时，不管使用子类的哪个构造器**，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器**，则必须在子类的构造器中用 **super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过**

4. 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)（一个类中允许有多个构造器）

   ```
   super()//或者什么都不写  调用无参构造器父类
   super("dwx")
   super("dwx",20)
   ```

   

5. super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)

6. super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器

   this() 调用本类的构造器

7. java 所有类都是 Object 类的子类, Object 是所有类的基类.

8. 父类构造器的调用不限于直接父类!将一直往上追溯直到Object类(顶级父类)

9. 子类最多只能继承一个父类(指直接继承)，即java中是**单继承机制**。

   

   思考:如何让A类继承B类和C类? 【A 继承 B， B继承C】

10. 10) 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系

    

    

如何按照查找关系来返回信息

1. 首先看子类是否有该属性
2. 有，可以访问 则返回信息
3. 如果没有。就看父类有没有（如果没有继续找上级父类）

继承本质分析

![image-20230516100737343](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230516100737343.png)

### super关键字

   super 代表父类的引用，用于访问父类的属性、方法、构造器

![image-20230516132031914](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230516132031914.png)

```
//方法内使用 
public void sum(){
 //找 cal 方法时(cal() 和 this.cal())，顺序是:
// (1)先找本类，如果有，则调用
// (2)如果没有，则找父类(如果有，并可以调用，则调用)
// (3)如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类 // 提示:如果查找方法的过程中，找到了，但是不能访问， 则报错, cannot access
// 属性也一样
 cal()
  this.cal()//同cal
  super.cal()// 直接查找父类
}
```

### 方法重写/覆盖

子类有一个方法和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的方法

重写与重载区别

| 名称 | 发生范围 | 方法名 | 形参列表           | 返回类型                       | 修饰符 |
| ---- | -------- | ------ | ------------------ | ------------------------------ | ------ |
| 重载 | 本类     | 相同   | 类型 个数 数量不同 | 无需求                         | 相同   |
| 重写 | 父子类   | 相同   | 相同               | 子类重写的类型是父类的子类类型 | 相同   |

面向对象编程-生态

Oject类详解

断点调试debug

项目--零钱通

## 第9章 房屋出租系统
