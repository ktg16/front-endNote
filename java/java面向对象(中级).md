## java中级部分

IDE基本使用

### ide快捷键

1.删除当前行 ctrl+d

2.复制当前行 ctrl+c

3.补全代码 alt+/

4.添加注释 ctrl + /

5.导入该行需要的类 先配置 auto import 使用alt+enter即可

6.快速格式化 ctrl+alt+L

7.快速运行 alt+r 

8.生成构造器 ctrl+n 						 					

9) 查看一个类的层级关系 ctrl + H [学习继承后，非常有用]  (破解之后才有) 						
10) 将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用]  ctrl+左键						
11) 自动的分配变量名 , 通过 在后面假 .var [老师最喜欢的] alt+回车  			

### 模版/自定义模版			

进阶的时候看 先手写 练一练手感

模版可以高效完成开发  提高速度 				

### 包

包的本质： 实际上就是创建不同的文件夹/目录来保存类文件

包的命名规则： 只能包含数字、字母、下划线、小圆点、但不能用数字开头，不能是关键字或保留字

demo.classs.exec1//x

命名规范：

一般是小写字母+小圆点

com.公司名.项目名.业务模块名

比如: com.enssi.his.use//用户模块

### 访问修饰符

![image-20230515092459031](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230515092459031.png)

不同包需要使用 import包引入，同一包下则不需要使用

### 面向对象编程--封装

封装就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序其他部分只有通过被授权的操作[方法]，才能对数据进行操作

![image-20230515094909171](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230515094909171.png)

将构造器和 setXxx 结合

```
public Person(String name, int age, double salary) {
// // //
      this.name = name; 
      this.age = age; 
      this.salary = salary;
      //我们可以将 set 方法写在构造器中，这样仍然可以验证 
      setName(name);
      setAge(age);
      setSalary(salary);
}

使用快捷键ctrl+i 构造get set
```

### 继承

继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中 抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来 声明继承父类即可

1.  代码的复用性提高了

2. 代码的扩展性和维护性提高了

   ```
   class子类 extends 父类{}
   子类就自动拥有父类定义的属性和方法
   子类又叫超类 基类
   子类又叫派生类
   ```

   继承细节问题

1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问

2. 子类必须调用父类的构造器，完成父类的初始化

3. 当创建子类对象时，不管使用子类的哪个构造器**，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器**，则必须在子类的构造器中用 **super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过**

4. 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)（一个类中允许有多个构造器）

   ```
   super()//或者什么都不写  调用无参构造器父类
   super("dwx")
   super("dwx",20)
   ```

   

5. super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)

6. super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器

   this() 调用本类的构造器

7. java 所有类都是 Object 类的子类, Object 是所有类的基类.

8. 父类构造器的调用不限于直接父类!将一直往上追溯直到Object类(顶级父类)

9. 子类最多只能继承一个父类(指直接继承)，即java中是**单继承机制**。

   

   思考:如何让A类继承B类和C类? 【A 继承 B， B继承C】

10. 10) 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系

    

    

如何按照查找关系来返回信息

1. 首先看子类是否有该属性
2. 有，可以访问 则返回信息
3. 如果没有。就看父类有没有（如果没有继续找上级父类）

继承本质分析

![image-20230516100737343](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230516100737343.png)

### super关键字

   super 代表父类的引用，用于访问父类的属性、方法、构造器

![image-20230516132031914](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230516132031914.png)

```
//方法内使用 
public void sum(){
 //找 cal 方法时(cal() 和 this.cal())，顺序是:
// (1)先找本类，如果有，则调用
// (2)如果没有，则找父类(如果有，并可以调用，则调用)
// (3)如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类 // 提示:如果查找方法的过程中，找到了，但是不能访问， 则报错, cannot access
// 属性也一样
 cal()
  this.cal()//同cal
  super.cal()// 直接查找父类
}
```

### 方法重写/覆盖

子类有一个方法和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的方法

重写与重载区别

| 名称 | 发生范围 | 方法名 | 形参列表           | 返回类型                       | 修饰符 |
| ---- | -------- | ------ | ------------------ | ------------------------------ | ------ |
| 重载 | 本类     | 相同   | 类型 个数 数量不同 | 无需求                         | 相同   |
| 重写 | 父子类   | 相同   | 相同               | 子类重写的类型是父类的子类类型 | 相同   |

### 面向对象编程-多态

使用多态利于代码维护，解决很多不必要的代码

方法或对象具有多种形态。是面向对象的第三大特征多态是建立在封装和继承基础之上的   

#### **1.方法的多态（重写/重载就是多态）**

#### **2.对象的多态**

1.一个对象的编译类型和运行类型可以不一致

2.编译类型在定义对象时，就确定了,不能改变

3.运行类型时可以变化的

4.**编译类型看定义时 = 号 的左边 运行类型看 = 号的右边**

```java
Animal animal = new Dog(); animal编译类型是Animal 运行类型Dog
  
animal.cry()因为是运行时执行 所以使用的是 dog的cry()
animal = new Cat(); animal的运行类型变成了Cat 编译类型仍然是Animal
  (披着羊皮的狼)

```

实例

```
//animal 编译类型是Animal 可以指向Animal子类的对象
// food 编译类型是Food。可以指向Food子类的对象
public void feed(Animal animal,Food food){
	System.out.println(""name+animal.getName()+food.getFood())
}
```

##### **向上转型**

```
pig ---- 
animal ---
object

object obj = new Pig()//把一个小的赋值给大的
```

可以调用父类中的所有成员，但不能调用子类的特有成员（就近原则）

能调用哪些成员,是由编译类型来决定的

***1.属性必须要看编译类型***

***2.方法必须要看运行类型***



##### **向下转型**

1.子类类型  引用名 = （子类类型）父类引用

2.只能强转父类的引用，不能强转父类的对象

3.要求父类的引用**必须指向的是当前目标类型的对象**

4.向下转型后 可以调用子类类型中所有的成员

```
Cat cat =（Cat）animal；
向下转型 大的变小的。 前提条件：小的需要继承大的// 如果被转了需要考虑是否可以转

Dog dog = （Dog）animal;//不可以执行继续执行了。 animal已经被指向dog了
```

**instanceOf（常用） 比较操作符**，用于判断对象的运行类型是否为xxx类型或xx子类型

![image-20230517142311839](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230517142311839.png)

#### 动态绑定机制（重点）

调用子类方法

1.当调用对象方法的时候，**该方法会和该对象的内存地址/运行类型绑定**

2.当调用对象属性时，**没有动态绑定机制，哪里声明，哪里使用**

```

```

#### 多态数组

```
数组的定义类型为父类类型，里面保存的实际元素类型为子类类型
Person[] persons = new Person[5];
persons[0] = new Person("jack", 20); 
persons[1] = new Student("mary", 18, 100); 
persons[2] = new Student("smith", 19, 30.1);
```

#### 多态参数

（easy）方法定义的形参类型为父类类型，实参类型允许为子类类型

```
    public void testWork(Employee e){
        if(e instanceof  Worker){
            ((Worker)e).work();
        } else if (e instanceof  Manager) {
            ((Manager)e).mange();
        }else{
            System.out.println("不做处理");
        }
    }
```

### Oject类详解

equals方法

==是一个比较运算符

1. == 既可以基本类型 又可以判断引用类型
2. 判断基本类型 判断的是值的区别
3. 判断引用类型。判断的是地址是否相等，即判定 是不是同一个对象
4. equals 是 object类中的方法。只能判断引用类型
5. 默认判断的地址是否相等。子类中往往重写该方法，用于判断内容是否相等

//equals 方法，源码怎么查看. //把光标放在 equals 方法，直接输入 ctrl+b //如果你使用不了. 自己配置. 即可使用.

hashCode方法

返回对象 hashCode 一段数字

1) 提高具有哈希结构的容器的效率!
2) 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的! 3) 两个引用，
3) 两个引用，如果指向的是不同对象，则哈希值是不一样的
4) 哈希值主要根据地址号来的!，不能完全将哈希值等价于地址。
5) 案例演示[HashCode_.java]: obj.hashCode() [测试:A obj1 = new A(); A obj2 = new A(); A obj3 = obj1] 6) 后面在集合，中hashCode如果需要的话，也会重写,在讲解集合时，老韩在说如何重写hashCode()

toString方法

1.默认返回：全类名+@+哈希值的十六进制，【查看 Object 的 toString 方法】

子类往往重写 toString 方法，用于返回对象的属性信息

```
public String ToString(){
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

2.重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式.

3.当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster); 就会默认调用

monster.toString()

finalize

1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作【演示】
2. 什么时候被回收:当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法。
3. 垃圾回收机制的调用，是由系统来决定(即有自己的GC算法),也可以通过System.gc()主动触发垃圾回收机制，测 试:Car [name]

老韩提示: 我们在实际开发中，几乎不会运用 finalize , 所以更多就是为了应付面试.

### 断点调试debug

快捷键

F7(跳入) F8(跳过) shift+F8(跳出) F9(resume,执行到下一个断点) F7:跳入方法内
 F8: 逐行执行代码.
 shift+F8: 跳出方法



f7跳入方法

shift f8 跳出方法

f9跳到下一个断点 （后期使用频繁）

### 项目--零钱通

编程思想1.判断条件时尽量找出不正确的点(尽量使用不正确条件进行判断)

OOP 面向对象思想：

把每一个方法都分开来写，进行封装

最后再使用 new mainMenu.show() 来执行操作

## 第9章 房屋出租系统

工作

https://www.cnblogs.com/linhan8888/p/17015776.html

https://segmentfault.com/q/1010000039916882

图标大小1024

云打包时候才能看到

视频 语音功能

第一次登录时加载不出聊天信息代码

在日常生活中保持平静，有以下几个建议： 1. 学会深呼吸：当你感到紧张或者压力大的时候，可以停下手头的工作，闭上眼睛，然后深呼吸5-10次，这样能够让你的身体和心态都平静下来。 2. 练习冥想：冥想是一种很好的放松方式，它可以帮助你控制心理上的烦恼和情绪。可以在家里选择一个安静的地方，以深度专注的方式进行冥想训练。 3. 找到你喜欢的事情：在忙碌的工作之余，做一些自己喜欢的事情，比如听音乐、看书、做运动等等。这样可以让你更加放松自己，提高自己的情绪状态。 4. 善待他人：待人友善，善待身边的人，可以让你的内心更加平静。无论在什么场合，用温和的态度与人相处，都能带来轻松和愉悦的感觉，也会让你得到更多的尊重和支持。 希望这些建议对您有所帮助，让你在日常生活中保持平静。





自己做东西 别依赖别人 也别告诉别人 没人会理 没人会同情 我不需要聊那些有的没得

一个人一台电脑

