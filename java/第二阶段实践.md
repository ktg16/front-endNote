不要因为别人的行为和话语影响到自己. 我有些极端了完全没必要这样子的。 每个人都有每个人的自由，既然这是他的决定，于我又何干

### 枚举

枚举类[枚: 一个一个 举: 例举 , 即把具体的对象一个一个例举出来的类



#### 枚举的二种实现方式

1) 自定义类实现枚举
2) 使用enum关键字实现枚举

#### enum关键字实现枚举--快速入门

```
enum Season2 {
    //1. 使用关键字 enum 替代 class
//2. public static final Season SPRING = new Season("春天", "温暖") 直接使用 // SPRING("春天", "温暖") 解读 常量名(实参列表)
//3. 如果有多个常量(对象)， 使用 ,号间隔即可
//4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面
//5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()
    SPRING("春天", "温暖"), WINTER("冬天", "寒冷"), AUTUMN("秋天", "凉爽"), SUMMER("夏天", "炎热")/*, What()*/;
    private String name;
    private String desc;//描述

    private Season2() {//无参构造器
    }

    private Season2(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }
}
```

1. 当我们使用enum 关键字开发一个枚举类时，默认会继承Enum类, 而且是一个final 类[如何证明],老师使用javap 工 具来演示
2. 传统的 public static final Season2 SPRING = new Season2("春天", "温暖"); 简化成 SPRING("春天", "温暖")， 这里必 须知道，它调用的是哪个构造器.
3. 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略
4. 当有多个枚举对象时，使用,间隔，最后有一个分号结尾

 5 .  枚举对象必须放在枚举类的行首.

#### 常用方法

![image-20230601172301059](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230601172301059.png)

```
   Season2 autumn = Season2.AUTUMN;
        //1.name
        System.out.println(autumn.name());
        //2.ordinal 获取序号
        System.out.println(autumn.ordinal());
        // 3. values()   含有定义的所有枚举对象 使用增强for遍历
        Season2[] values = Season2.values();
        System.out.println("===遍历取出枚举对象=====");
        for(Season2 season2:values){
            System.out.println(season2);
        }
        //3.valueOf:将字符串转换成枚举对象，要求字符串必须 为已有的常量名，否则报异常

        Season2 autumn1 = Season2.valueOf("AUTUMN");
        System.out.println("autumn"+autumn1);
        System.out.println(autumn == autumn1);
        //4.compareTo：比较两个枚举常量，比较的就是编号
        System.out.println(Season2.AUTUMN.compareTo(Season2.SPRING));
```

#### 实现接口

1) 使用enum关键字后，就不能再继承其它类了，因为enum会隐式继承Enum，而Java是单继承机制。
2)  2) 枚举类和普通类一样，可以实现接口，如下形式。

enum 类名 implements 接口 1，接口 2{}

```
interfance IPlaying{
  public void playing(){
  
  }
}

enum Music implements IPlaying { CLASSICMUSIC;
@Override
public void playing() {
System.out.println("播放好听的音乐..."); }
}
```

### 注解的理解

1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。

```
1) @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法
2) @Deprecated: 用于表示某个程序元素(类, 方法等)已过时
3) @SuppressWarnings: 抑制编译器警告
```

### 元注解

如果有了解的需要请查看详细文档

### 异常

将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错不是异常）



1.Error：Java虚拟机无法解决的严重问题

2.Exception：编程错误或外在因素导致一般性问题，可以使用针对性的代码处理

分为运行时异常和编译时异常

#### 运行时异常和编译时异常

1.运行异常，编译器检查不出来。一般是指编程时的逻辑错误

2.对于运行异常可以不做处理，因为 这类异常很普遍

3.编译异常是 编译器要求必须处置的异常

#####  RuntimeException

![image-20230606082306894](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606082306894.png)

​	6. ArrayIndexOutBoundsException.   缺少命令行参数

##### Exception编译异常

![image-20230606091511708](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606091511708.png)

#### 异常处理

1.try-catch-finally

2.throws

![image-20230606092335158](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606092335158.png)

try catch 方式处理异常-注意事项

![image-20230606095029305](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606095029305.png)

//2.可以使用多个 catch 分别捕获不同的异常，相应处理 

//3.要求子类异常写在前面，父类异常写在后面

#### throws异常处理			 		 		 		 		 		 	

![image-20230606102750748](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606102750748.png)



//1.对于编译异常，程序中必须处理，比如 try-catch 或者 throws

 //2.对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理

#### 自定义异常

![image-20230606110113134](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606110113134.png)

```
public class CustomException {
  public static void main(String[] args) /*throws AgeException*/ {
    int age = 180;
    //要求范围在 18 – 120 之间，否则抛出一个自定义异常 if(!(age >= 18 && age <= 120)) {
    //这里我们可以通过构造器，设置信息
    throw new AgeException("年龄需要在 18~120 之间"); }
    System.out.println("你的年龄范围正确."); }
}

class AgeException extends RuntimeException { 
    public AgeException(String message) {//构造器
    super(message); }
}
```



throw 和 throws 的区别

![image-20230606105941851](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606105941851.png)

![image-20230606111644185](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606111644185.png)

finally在抛出异常之前发生



```
static void methodA(){
	try{
			System.out.println("进入方法A") //1
			throw new RuntimeException("制造异常") // 3
	} finally {
	 		System.out.println("用A方法的finally")// 2
	}
}
```

### idea参数配置  

运行标志右键配置。Program arguments

所有真实的快乐，都需要长久的铺垫和努力。



### 包装类

| 基本数据类 |  包装类   |
| :--------: | :-------: |
|  boolean   |  Boolean  |
|    char    | character |
|   short    |   Short   |
|    int     |  Integer  |
|    long    |   Long    |
|   float    |   Float   |
|   double   |  Double   |
|    byte    |   Byte    |

包装类和基本数据类比较

```
int a = 10 
Integer A = Inerger.valueOf(a)
// 现在可以直接转化
Integer A = a
```



```
Object obj1 = true?new Integer(1):new Double(2.0)//三元运算符是一个整体  一真大师
//1.0 取最高级优先级
```

string与integer交换

```
//方式 1
 String str1 = i + "";
 //方式 2
 String str2 = i.toString(); 
 //方式 3
 String str3 = String.valueOf(i);

//String -> 包装类(Integer)
 String str4 = "12345";
 Integer i2 = Integer.parseInt(str4);
 //使用到自动装箱 
 Integer i3 =new Integer(str4);//构造器


```

Integer类 和 Character类

```
 System.out.println(Integer.MIN_VALUE); 返回最小值
        Character.isDigit('a'); 判断是不是数字
        Character.isLetter('a'); 判断是不是字母

        Character.isUpperCase('a'); 判断是不是大写
        Character.isLowerCase('a'); 小写
        Character.isWhitespace('a'); 空格
        Character.toUpperCase('a');  转换成大写
        Character.toLowerCase('A');  小写
```

#### Integer 面试题

```
Integer i = new Integer(1);
Integer j = new Integer(1);
System.out.println(i == j); //False new出来的肯定是false

//所以，这里主要是看范围 -128 ~ 127 就是直接返回
//1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回 //2. 如果不在 -128~127,就直接 new Integer(i)
public static Integer valueOf(int i) {
      if (i >= IntegerCache.low && i <= IntegerCache.high)
      	return IntegerCache.cache[i + (-IntegerCache.low)]; 
      	return new Integer(i);
      } */
      Integer m = 1; //底层 Integer.valueOf(1); -> 阅读源码 
      Integer n = 1;//底层 Integer.valueOf(1); 	
      System.out.println(m == n); //T //所以，这里主要是看范围 -128 ~ 127 就是直接返回 //，否则，就 new Integer(xx);
      
      Integer x = 128;//底层 Integer.valueOf(1); 
      Integer y = 128;//底层 Integer.valueOf(1); 
      System.out.println(x == y);//False
} }


Integer i11=127; int i12=127;
//只有有基本数据类型，判断的是 //值是否相同
System.out.println(i11==i12); //T //示例七
Integer i13=128;
int i14=128; System.out.println(i13==i14);//T
```

### String类



String 实现了 Serializable 说明String可以串行化 可以在网络上传输

实现了Comparable接口   String对象可以比较

1.用于保存字符串

2.字符串常量对象是用双引号括起来的字符序列

3.使用Unicode字符编码。一个字符(不区分字母还是汉字)占两个字节

4.String类常用构造器：



（Sting类有很多）

```
String s1 = new String()
String s2 = new String(String original)
String s3 = new String(char[] a);
String s4 = new String(char[] a,int startIndex,int count)
String S5 = new String(byte)
```

//5. String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】 

// 接口 Comparable [String 对象可以比较大小]

//6. String 是 final 类，不能被其他的类继承
 //7. String 有属性 private final char value[]; 用于存放字符串内容
 //8. 一定要注意:value 是一个 final 类型， 不可以修改(需要功力):即 value 不能指向 // 新的地址，但是单个字符内容是可以变化

创建对象的区别

![image-20230607110201310](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230607110201310.png)

字符串特性

![image-20230607111539711](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230607111539711.png)

```
String a = "hello";
String b = "abc";
String c = a+b; //执行了什么

StringBuilder sb = new StringBuilder(); 
	sb.append(a);
	sb.append(b);
	String str = sb.toString();
	sb是在堆中，并且append是在原来字符串的基础上追加的
	
```

#### String的方法

```
equals //区分大小写，判断内容
equalsIgnoreCase
length
indexOf	//第一次
lastIndexOf // 获取字符在字符串中最后一次出现的索引
substring //截取指定范围的子串
trim   //去掉前后空格
charAt //获取某索引出的字符
toUpperCase
toLowrCase
concat // 拼接字符串
replace // 替换字符串中的字符
split // 分割字符串
compareTo //比较字符串 前者大返回正数，后者大返回负数，相等返回0
toCharArray //转成字符数组
format  //格式化数据

String name = "john"; int age = 10;
double score = 56.857; char gender = '男';
String formatStr = "我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我!";
String info2 = String.format(formatStr, name, age, score, gender);
//1. %s , %d , %.2f %c 称为占位符
//2. 这些占位符由后面变量来替换
//3. %s 表示后面由 字符串来替换
//4. %d 是整数来替换
//5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理 //6. %c 使用 char 类型来替换
```

### StringBuffer 类

//1. StringBuffer 的直接父类 是 AbstractStringBuilder

//2.说明StringBuffer可以串行化 可以在网络上传输

//3.在父类中 AbstractStringBuilder 有属性 char[] value,不是 final

该 value 数组存放 字符串内容，引出存放在堆中的

//4. StringBuffer 是一个 final 类，不能被继承
 //5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)，可以对字符串内容进行增删

//不用每次都更换地址（即不是每次创建新对象），所以效率高于String

#### String和StringBuffer的相互转换

```
String——>StringBuffer
String str = "hello tom";
//方式 1 使用构造器
//注意: 返回的才是 StringBuffer 对象，对 str 本身没有影响 StringBuffer stringBuffer = new StringBuffer(str);
//方式 2 使用的是 append 方法
StringBuffer stringBuffer1 = new StringBuffer();
stringBuffer1 = stringBuffer1.append(str);
//看看 StringBuffer ->String
StringBuffer stringBuffer3 = new StringBuffer("韩顺平教育"); //方式 1 使用 StringBuffer 提供的 toString 方法
String s = stringBuffer3.toString();
//方式 2: 使用构造器来搞定
String s1 = new String(stringBuffer3);
```

#### StringBuffer方法

```
 StringBuffer strB = new StringBuffer();
        
        strB.append(str);
        strB.delete(0,1);
        strB.replace(0,1,"dwx");
        strB.indexOf("dwx");
        strB.insert(0,"kk");
        strB.length()
```

