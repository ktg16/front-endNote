不要因为别人的行为和话语影响到自己. 我有些极端了完全没必要这样子的。 每个人都有每个人的自由，既然这是他的决定，于我又何干

### 枚举

枚举类[枚: 一个一个 举: 例举 , 即把具体的对象一个一个例举出来的类



#### 枚举的二种实现方式

1) 自定义类实现枚举
2) 使用enum关键字实现枚举

#### enum关键字实现枚举--快速入门

```
enum Season2 {
    //1. 使用关键字 enum 替代 class
//2. public static final Season SPRING = new Season("春天", "温暖") 直接使用 // SPRING("春天", "温暖") 解读 常量名(实参列表)
//3. 如果有多个常量(对象)， 使用 ,号间隔即可
//4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面
//5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()
    SPRING("春天", "温暖"), WINTER("冬天", "寒冷"), AUTUMN("秋天", "凉爽"), SUMMER("夏天", "炎热")/*, What()*/;
    private String name;
    private String desc;//描述

    private Season2() {//无参构造器
    }

    private Season2(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }
}
```

1. 当我们使用enum 关键字开发一个枚举类时，默认会继承Enum类, 而且是一个final 类[如何证明],老师使用javap 工 具来演示
2. 传统的 public static final Season2 SPRING = new Season2("春天", "温暖"); 简化成 SPRING("春天", "温暖")， 这里必 须知道，它调用的是哪个构造器.
3. 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略
4. 当有多个枚举对象时，使用,间隔，最后有一个分号结尾

 5 .  枚举对象必须放在枚举类的行首.

#### 常用方法

![image-20230601172301059](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230601172301059.png)

```
   Season2 autumn = Season2.AUTUMN;
        //1.name
        System.out.println(autumn.name());
        //2.ordinal 获取序号
        System.out.println(autumn.ordinal());
        // 3. values()   含有定义的所有枚举对象 使用增强for遍历
        Season2[] values = Season2.values();
        System.out.println("===遍历取出枚举对象=====");
        for(Season2 season2:values){
            System.out.println(season2);
        }
        //3.valueOf:将字符串转换成枚举对象，要求字符串必须 为已有的常量名，否则报异常

        Season2 autumn1 = Season2.valueOf("AUTUMN");
        System.out.println("autumn"+autumn1);
        System.out.println(autumn == autumn1);
        //4.compareTo：比较两个枚举常量，比较的就是编号
        System.out.println(Season2.AUTUMN.compareTo(Season2.SPRING));
```

#### 实现接口

1) 使用enum关键字后，就不能再继承其它类了，因为enum会隐式继承Enum，而Java是单继承机制。
2)  2) 枚举类和普通类一样，可以实现接口，如下形式。

enum 类名 implements 接口 1，接口 2{}

```
interfance IPlaying{
  public void playing(){
  
  }
}

enum Music implements IPlaying { CLASSICMUSIC;
@Override
public void playing() {
System.out.println("播放好听的音乐..."); }
}
```

### 注解的理解

1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。

```
1) @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法
2) @Deprecated: 用于表示某个程序元素(类, 方法等)已过时
3) @SuppressWarnings: 抑制编译器警告
```

### 元注解

如果有了解的需要请查看详细文档

### 异常

将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错不是异常）



1.Error：Java虚拟机无法解决的严重问题

2.Exception：编程错误或外在因素导致一般性问题，可以使用针对性的代码处理

分为运行时异常和编译时异常

#### 运行时异常和编译时异常

1.运行异常，编译器检查不出来。一般是指编程时的逻辑错误

2.对于运行异常可以不做处理，因为 这类异常很普遍

3.编译异常是 编译器要求必须处置的异常

#####  RuntimeException

![image-20230606082306894](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606082306894.png)

​	6. ArrayIndexOutBoundsException.   缺少命令行参数

##### Exception编译异常

![image-20230606091511708](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606091511708.png)

#### 异常处理

1.try-catch-finally

2.throws

![image-20230606092335158](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606092335158.png)

try catch 方式处理异常-注意事项

![image-20230606095029305](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606095029305.png)

//2.可以使用多个 catch 分别捕获不同的异常，相应处理 

//3.要求子类异常写在前面，父类异常写在后面

#### throws异常处理			 		 		 		 		 		 	

![image-20230606102750748](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606102750748.png)



//1.对于编译异常，程序中必须处理，比如 try-catch 或者 throws

 //2.对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理

#### 自定义异常

![image-20230606110113134](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606110113134.png)

```
public class CustomException {
  public static void main(String[] args) /*throws AgeException*/ {
    int age = 180;
    //要求范围在 18 – 120 之间，否则抛出一个自定义异常 if(!(age >= 18 && age <= 120)) {
    //这里我们可以通过构造器，设置信息
    throw new AgeException("年龄需要在 18~120 之间"); }
    System.out.println("你的年龄范围正确."); }
}

class AgeException extends RuntimeException { 
    public AgeException(String message) {//构造器
    super(message); }
}
```



throw 和 throws 的区别

![image-20230606105941851](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606105941851.png)

![image-20230606111644185](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20230606111644185.png)

finally在抛出异常之前发生



```
static void methodA(){
	try{
			System.out.println("进入方法A") //1
			throw new RuntimeException("制造异常") // 3
	} finally {
	 		System.out.println("用A方法的finally")// 2
	}
}
```

### idea参数配置  

运行标志右键配置。Program arguments

所有真实的快乐，都需要长久的铺垫和努力。



### 包装类

| 基本数据类 |  包装类   |
| :--------: | :-------: |
|  boolean   |  Boolean  |
|    char    | character |
|   short    |   Short   |
|    int     |  Integer  |
|    long    |   Long    |
|   float    |   Float   |
|   double   |  Double   |
|    byte    |   Byte    |

包装类和基本数据类比较

```
int a = 10 
Integer A = Inerger.valueOf(a)
// 现在可以直接转化
Integer A = a
```



```
Object obj1 = true?new Integer(1):new Double(2.0)//三元运算符是一个整体  一真大师
//1.0 取最高级优先级
```

string与integer交换

```
//方式 1
 String str1 = i + "";
 //方式 2
 String str2 = i.toString(); 
 //方式 3
 String str3 = String.valueOf(i);

//String -> 包装类(Integer)
 String str4 = "12345";
 Integer i2 = Integer.parseInt(str4);
 //使用到自动装箱 
 Integer i3 =new Integer(str4);//构造器


```

Integer类 和 Character类

```
 System.out.println(Integer.MIN_VALUE); 返回最小值
        Character.isDigit('a'); 判断是不是数字
        Character.isLetter('a'); 判断是不是字母

        Character.isUpperCase('a'); 判断是不是大写
        Character.isLowerCase('a'); 小写
        Character.isWhitespace('a'); 空格
        Character.toUpperCase('a');  转换成大写
        Character.toLowerCase('A');  小写
```

Integer 面试题

```
Integer i = new Integer(1);
Integer j = new Integer(1);
System.out.println(i == j); //False //所以，这里主要是看范围 -128 ~ 127 就是直接返回


//1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回 //2. 如果不在 -128~127,就直接 new Integer(i)
public static Integer valueOf(int i) {
      if (i >= IntegerCache.low && i <= IntegerCache.high)
      	return IntegerCache.cache[i + (-IntegerCache.low)]; 
      	return new Integer(i);
      } */
      Integer m = 1; //底层 Integer.valueOf(1); -> 阅读源码 
      Integer n = 1;//底层 Integer.valueOf(1); 	
      System.out.println(m == n); //T //所以，这里主要是看范围 -128 ~ 127 就是直接返回 //，否则，就 new Integer(xx);
      
      Integer x = 128;//底层 Integer.valueOf(1); 
      Integer y = 128;//底层 Integer.valueOf(1); 
      System.out.println(x == y);//False
} }
```

