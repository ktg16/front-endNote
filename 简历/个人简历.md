### 项目知识点总结及答案

### 恩熙工作台项目



#### 登陆鉴权

jwt鉴权存在一个问题就是。 

1.判断token是否过期 过期了就使用刷新token重新获取没过期就不用操作，

2.刷新令牌 RefrshToken过期了 就跳回登陆

如何判断登陆过期

刷新令牌（Refresh Token）

        在用户登录时，除了发放一个访问令牌（Access Token）以外，再发放一个刷新令牌（Refrsh Token）。
    
        访问令牌的有效期比较短，刷新令牌的有效期比较长。
    
        当访问令牌过期时，使用刷新令牌向服务器请求新的访问令牌。如果刷新令牌也过期，则跳转回登录界面。
    
        这种方式的优点是可以避免用户频繁登录，但需要妥善保管刷新令牌，因为它的安全性比访问令牌更高。

还有就是时间戳

学习 rbac权限

复习 promise

学习源码

https://www.tailwindcss.cn/docs/installation

先不准备面试题 先玩玩算法题和源码

我只知道向前努力



专业技能

熟练使用 HTML,CSS,JavaScript 等前端技术
熟练使用 Vue3、Vue2 及 React 等前端框架
熟练使用使用 Antd、Element-ui、Vant 等主流 UI 框架
熟练常用的前后端跨域方法及 axios、ajax 异步(同步)操作实现前后端数据交互
熟练使用 ES5/6/7 特性、sass、less、 echarts 进行页面开发
熟练使用 DataV 进行可视化页面开发
熟悉 npm、Git、yarn、webpack 等构建开发工具的使用
了解 ReactNative、nodeJS、TypeScript、MySQL 等相关技术

根据什么什么 做了什么什么 达到什么什么效果

### 项目经历

#### 恩熙健康

技术要点：Vue3.0+vue-cli4.0+vuex+axios+vant+Hybrid+postcss-pxtorem+socket.io-client+Echarts+indexedDB 等 

项目描述：使用 App 混合式开发的 app ，可以通过蓝牙连接血糖仪，血压计设备，进行测量并查看数据，用户可以通过本 app 查看个人在本院体检记录及开药处方等，可以使用手机支付处方 

技术实现： 1.使用 Hybrid 实现H5页面与 native 互通，从而实现项目功能 2.使用前端本地存储 indexedDB 数据库及哈希表方式来实现会话列表及聊天记录的存储 3.使用 postcss-pxtorem、lib-flexible 实现对移动端的适配，使用 better-scroll 优化滚动加载效果 4.页面交互复杂，使用 vuex 状态管理工具存储用户信息及头像、配合 sockiet.io 使用等，极大的方便了后期迭代开发工作 5.使用 vue-cli 配置项 proxy 代理实现跨域，封装 axios 实现前后端交互 6.使用 sockiet.io 实现聊天及群聊功能 7.优化系统结构和改进轮询实现屏幕耗时减少约30%8.实现微信支付

9.项目优化 打包优化

恩熙工作台



#### 根据项目需求实现jwt登陆鉴权

#### 实现rbac权限方便各级用户操作

##### 菜单权限

页面整体的菜单存放在 [wholeMenus (opens new window)](https://gitee.com/yiming_chang/pure-admin-thin/blob/main/src/store/modules/permission.ts#L13)，所以我们只需要控制 `wholeMenus` 就能控制菜单的显示、隐藏。通过 [filterNoPermissionTree (opens new window)](https://gitee.com/yiming_chang/pure-admin-thin/blob/main/src/router/utils.ts#L85)函数从菜单中过滤无权限的菜单(过滤无权限菜单)

```
/** 过滤meta中showLink为false的菜单 */
function filterTree(data: RouteComponent[]) {
  const newTree = cloneDeep(data).filter(
    (v: { meta: { showLink: boolean } }) => v.meta?.showLink !== false
  );
  newTree.forEach(
    (v: { children }) => v.children && (v.children = filterTree(v.children))
  );
  return newTree;
}
handleWholeMenus(routes: any[]) {
      this.wholeMenus = filterNoPermissionTree(
        filterTree(ascending(this.constantMenus.concat(routes)))
      );
    },
```

无权限菜单直接渲染

[#](https://yiming_chang.gitee.io/pure-admin-doc/pages/RBAC/#如何配置

将菜单与路由解藕，这样可以更灵活的控制二者，不会造成一方改动必会影响另一方

##### url链接权限

平台在路由的 [beforeEach (opens new window)](https://gitee.com/yiming_chang/pure-admin-thin/blob/main/src/router/index.ts#L98)钩子函数中，通过对比当前用户的角色和当前路由中 `roles` 字段来判断是否有无权限

```
if (to.meta?.roles && !isOneOfArray(to.meta?.roles, userInfo?.roles)) {
      next({ path: "/error/403" });
    }
```

##### 按钮、组件、类方法权限

###### 

平台提供三种方法 [组件方式判断权限](https://yiming_chang.gitee.io/pure-admin-doc/pages/RBAC/#组件方式判断权限)、[函数方式判断权限](https://yiming_chang.gitee.io/pure-admin-doc/pages/RBAC/#函数方式判断权限)、[指令方式判断权限](https://yiming_chang.gitee.io/pure-admin-doc/pages/RBAC/#指令方式判断权限)

在使用这三种方法前，需要通过返回路由的 `auths` 配置项，赋予该页面按钮级别权限



```
meta:{
	auths:["btn_add","btn_delete","btn_edit"]
}
```

###### 组件方式判断权限

注册auth组件 

```
import { defineComponent, Fragment } from "vue";
import { hasAuth } from "@/router/utils";

export default defineComponent({
  name: "Auth",
  props: {
    value: {
      type: undefined,
      default: []
    }
  },
  setup(props, { slots }) {//新方法 jsx/tsx写法
    return () => {
      if (!slots) return null;
      return hasAuth(props.value) ? (
        <Fragment>{slots.default?.()}</Fragment>
      ) : null;
    };
  }
});
//使用
<Auth value="btn_add">
  <el-button type="success"> 拥有code：'btn_add' 权限可见 </el-button>
</Auth>
```

###### 函数方式判断权限

通过 [hasAuth (opens new window)](https://gitee.com/yiming_chang/pure-admin-thin/blob/main/src/router/utils.ts#L354)函数判断某些按钮、组件、类方法是否有按钮级别的权限

###### 

```
<el-button type="success" v-if="hasAuth('btn_add')">
  拥有code：'btn_add' 权限可见
</el-button>
```



###### 指令方式判断：创建自定义指令

```
//创建指令
import { hasAuth } from "@/router/utils";
import type { Directive, DirectiveBinding } from "vue";

export const auth: Directive = {
  mounted(el: HTMLElement, binding: DirectiveBinding) {
    const { value } = binding;
    if (value) {
      !hasAuth(value) && el.parentNode?.removeChild(el); （前面为假后面不执行）
    } else {
      throw new Error(
        "[Directive: auth]: need auths! Like v-auth=\"['btn.add','btn.edit']\""
      );
    }
  }
};

function hasAuth(value: string | Array<string>): boolean {
  if (!value) return false;
  /** 从当前路由的`meta`字段里获取按钮级别的所有自定义`code`值 */
  const metaAuths = getAuths();
  if (!metaAuths) return false;
  const isAuths = isString(value)
    ? metaAuths.includes(value)
    : isIncludeAllChildren(value, metaAuths);
  return isAuths ? true : false;
}
main.ts 注册自定义指令
// 自定义指令
import * as directives from "@/directives";
Object.keys(directives).forEach(key => {
  app.directive(key, (directives as { [key: string]: Directive })[key]);
});
//btn_add权限可见
<el-button type="success" v-auth="'btn_add'">
        拥有code：'btn_add' 权限可见
      </el-button>
```





#### 岗位职责：

1、负责现有项目和新增项目的前端开发和联调工作；
2、 与设计师、产品经理紧密配合，保证产品具有优质的用户体验与良好的兼容性；
3、 Web前沿技术研究和新技术调研并用于实践；
4、 优化产品设计方案，优化产品中的性能问题。
5、 根据工作安排高效、高质地完成代码编写，确保代码符合前端代码规范。
任职要求：
1、本科以上学历，计算机相关专业；
2、3年及以上Web前端工作经验，熟悉HTML5、CSS，css3，JavaScript等开发语言，JS模块化、ES6、NPM以及Webpack打包工具；
3、熟练使用主流框架Vue和Vue全家桶，有一定的Vue项目的实战经验，能够独立使用Vue框架设计完成项目开发；
4、理解Web标准，对前端性能、模块化开发等有一定的了解；
5、对前端新技术敏感，善于学习新事物，善于沟通和表达，有较强的分析问题和解决问题的能力。





### 学习部分

openlayer和Echart可视化技术。创建大屏地图 进行数据铺点与展示

封装地图图层切换组件。excel文件导出组件 时间筛选组件。 多页面复用减少代码量提高效率

![image-20231024105252156](/Users/duwenxuan/Library/Application Support/typora-user-images/image-20231024105252156.png)

1.图片打包 

​		base64。体积更大（3/1）

2.cdn





https://juejin.cn/post/6872111128135073806#heading-88





显示传参 query 隐式传参 param





打包优化是指在前端开发中，通过一系列的技术手段来提高项目的打包效率和运行性能，以优化用户体验和提升网页加载速度。

在进行打包优化时，可以采取以下几个方面的措施：

1. 代码压缩：通过使用压缩工具，如UglifyJS、Terser等，对源代码进行压缩，去除空格、注释和不必要的字符，从而减小文件体积。
2. 代码拆分：将大型的代码库拆分成多个较小的模块，按需加载，避免一次性加载过多的代码，提高页面加载速度。可以使用Webpack等工具进行代码拆分。
3. 按需加载：对于一些不常用的功能或组件，可以采用按需加载的方式，即在需要使用时再动态加载相关代码，减少首次加载时的文件体积。
4. Tree Shaking：利用ES6模块系统的静态特性，通过工具（如Webpack、Rollup等）识别和删除项目中未使用的代码，减少打包后的文件大小。
5. 图片优化：对于图片资源，可以通过压缩、转换格式、懒加载等方式进行优化，减小图片文件大小和数量，提高网页加载速度。
6. CDN加速：将静态资源（如CSS、JS文件）存放在CDN服务器上，通过就近访问CDN节点，减少用户访问时的延迟，提高页面加载速度。
7. 缓存策略：使用合理的缓存策略，如设置合适的缓存头、使用Service Worker等，可以减少对服务器的请求，提高页面加载速度。



1. 减少HTTP请求：减少页面加载时需要发送的HTTP请求次数，可以合并CSS和JS文件，使用CSS Sprites技术合并图片，减少图片数量。
2. 压缩文件：对CSS和JS文件进行压缩，去除空格、注释和不必要的字符，减小文件体积，加快加载速度。可以使用工具如UglifyJS、Terser等。
3. 使用缓存：合理设置缓存头，利用浏览器缓存机制，减少对服务器的请求。可以通过设置Expires、Cache-Control等HTTP头来控制缓存策略。
4. 延迟加载：将页面中不需要首次加载的内容，如图片、广告等，延迟到用户需要时再加载，减少首屏加载时间。
5. 预加载：在页面加载完成后，提前加载一些将来可能会用到的资源，如异步加载JS文件、懒加载图片等，减少用户等待时间。
6. 使用CDN加速：将静态资源（如CSS、JS文件）存放在CDN服务器上，通过就近访问CDN节点，减少用户访问时的延迟，提高页面加载速度。
7. 减小DOM操作：减少对DOM的操作次数，避免频繁的重新渲染和回流。可以将多个DOM操作合并成一个批量操作，使用DocumentFragment等技术减少DOM插入次数。
8. 图片优化：对图片进行压缩、转换格式、懒加载等方式进行优化，减小图片文件大小和数量，提高网页加载速度。
9. 使用异步加载：将不影响页面展示的脚本放在异



1.给img绑定个属性data-src 再把值赋值给src